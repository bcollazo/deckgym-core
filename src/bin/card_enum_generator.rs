use std::{
    collections::HashSet,
    fs::File,
    io::{BufRead, BufReader, Read},
};

use clap::Parser;

use deckgym::models::{Ability, Attack, Card, EnergyType};
use indexmap::IndexMap;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Flag to generate the database.rs instead. card_ids.rs is generated by default.
    #[arg(long)]
    database: bool,

    /// Flag to generate the implementation_ids.rs file (maps effect texts to implementations).
    #[arg(long)]
    implementation_ids: bool,
}

/// A CLI program to generate card_ids.rs and database.rs from the database.json file.
fn main() {
    let args = Args::parse();

    // Read the JSON file into Card structs
    let mut file = File::open("./database.json").expect("database.json should be there");
    let mut json_string = String::new();
    file.read_to_string(&mut json_string)
        .expect("Unable to read string");
    let deserialized_cards: Vec<Card> = serde_json::from_str(&json_string).unwrap();

    // Generate the Enum Names
    let mut card_map: IndexMap<String, Card> = IndexMap::new();
    let mut id_to_enum: IndexMap<String, String> = IndexMap::new();
    for card in deserialized_cards {
        // Remove special characters from the name
        let mut enum_name = (card.get_id() + &card.get_name())
            .replace(" ", "")
            .replace("-", "")
            .replace(".", "")
            .replace("'", "")
            .replace("♀", "F")
            .replace("♂", "M")
            .replace(":", "")
            .replace("é", "e");
        if enum_name.ends_with("ex") {
            enum_name = enum_name[..enum_name.len() - 2].to_string();
            enum_name.push_str("Ex");
        }
        card_map.insert(enum_name.clone(), card.clone());
        id_to_enum.insert(card.get_id().clone(), enum_name.clone());
    }

    if args.database {
        print_database(&card_map);
    } else if args.implementation_ids {
        print_implementation_ids(&card_map, &id_to_enum);
    } else {
        print_enums(&card_map, &id_to_enum);
    }
}

fn print_enums(card_map: &IndexMap<String, Card>, id_to_enum: &IndexMap<String, String>) {
    println!("// This is code generated from the database.json by card_enum_generator.rs. Do not edit manually.");
    println!();
    println!("use serde::{{Deserialize, Serialize}};");
    println!("use strum_macros::EnumIter;");
    println!("use std::collections::HashMap;");
    println!("use std::sync::LazyLock;");
    println!();
    println!(
        "#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, Serialize, Deserialize, EnumIter)]"
    );
    println!("pub enum CardId {{");
    for (name, _) in card_map.iter() {
        println!("    {name},");
    }
    println!("}}\n");
    println!();
    println!("static CARD_ID_MAP: LazyLock<HashMap<&'static str, CardId>> = LazyLock::new(|| {{");
    println!("    let mut map = HashMap::new();");
    for (id, enum_name) in id_to_enum.iter() {
        println!("    map.insert(\"{id}\", CardId::{enum_name});");
    }
    println!("    map");
    println!("}});");
    println!();
    println!("impl CardId {{");
    println!("    pub fn from_card_id(id: &str) -> Option<Self> {{");
    println!("        CARD_ID_MAP.get(id).copied()");
    println!("    }}");
    println!();
    println!("}}");
}

fn print_database(card_map: &IndexMap<String, Card>) {
    println!("// This is code generated from the database.json by card_enum_generator.rs. Do not edit manually.");
    println!();
    println!("use crate::{{");
    println!("    card_ids::CardId,");
    println!(
        "    models::{{Ability, Attack, Card, EnergyType, PokemonCard, TrainerCard, TrainerType}},"
    );
    println!("}};");
    println!();
    println!("pub fn get_card_by_enum(id: CardId) -> Card {{");
    println!("    match id {{");
    for (enum_name, card) in card_map.iter() {
        print_card(enum_name, card);
    }
    println!("    }}");
    println!("}}");
}

fn print_card(enum_name: &str, card: &Card) {
    match card {
        Card::Pokemon(pokemon_card) => {
            println!("        CardId::{enum_name} => Card::Pokemon(PokemonCard {{");
            println!("            id: \"{}\".to_string(),", pokemon_card.id);
            println!("            name: \"{}\".to_string(),", pokemon_card.name);
            println!("            stage: {},", pokemon_card.stage);
            println!(
                "            evolves_from: {},",
                to_rust_string(&pokemon_card.evolves_from)
            );
            println!("            hp: {},", pokemon_card.hp);
            println!(
                "            energy_type: EnergyType::{},",
                pokemon_card.energy_type
            );
            println!(
                "            ability: {},",
                to_rust_ability(&pokemon_card.ability)
            );
            print_attacks(&pokemon_card.attacks);
            println!(
                "            weakness: {},",
                to_rust_energy(pokemon_card.weakness)
            );
            println!(
                "            retreat_cost: {},",
                to_rust_energy_vec(&pokemon_card.retreat_cost)
            );
            println!(
                "            rarity: \"{}\".to_string(),",
                pokemon_card.rarity
            );
            println!(
                "            booster_pack: \"{}\".to_string(),",
                pokemon_card.booster_pack
            );
            println!("        }}),");
        }
        Card::Trainer(trainer_card) => {
            println!("        CardId::{enum_name} => Card::Trainer(TrainerCard {{");
            println!("            id: \"{}\".to_string(),", trainer_card.id);
            println!("            name: \"{}\".to_string(),", trainer_card.name);
            println!(
                "            effect: \"{}\".to_string(),",
                trainer_card.effect
            );
            println!(
                "            rarity: \"{}\".to_string(),",
                trainer_card.rarity
            );
            println!(
                "            booster_pack: \"{}\".to_string(),",
                trainer_card.booster_pack
            );
            println!(
                "            trainer_card_type: TrainerType::{:?},",
                trainer_card.trainer_card_type
            );
            println!("        }}),");
        }
    }
    // TODO: AttackIds and AbilitiesIds
}

fn print_attacks(attacks: &[Attack]) {
    println!("            attacks: vec![");
    for attack in attacks {
        println!("                Attack {{");
        println!(
            "                    energy_required: {},",
            to_rust_energy_vec(&attack.energy_required)
        );
        println!(
            "                    title: \"{}\".to_string(),",
            attack.title
        );
        println!("                    fixed_damage: {},", attack.fixed_damage);
        println!(
            "                    effect: {},",
            to_rust_string(&attack.effect)
        );
        println!("                }},");
    }
    println!("            ],");
}

fn to_rust_string(string: &Option<String>) -> String {
    match string {
        Some(string) => format!("Some(\"{string}\".to_string())"),
        None => "None".to_string(),
    }
}
fn to_rust_ability(ability: &Option<Ability>) -> String {
    match ability {
        Some(ability) => format!(
            "Some(Ability {{ title: \"{}\".to_string(), effect: \"{}\".to_string() }})",
            ability.title, ability.effect
        ),
        None => "None".to_string(),
    }
}
fn to_rust_energy(energy_type: Option<EnergyType>) -> String {
    match energy_type {
        Some(energy_type) => format!("Some(EnergyType::{energy_type})"),
        None => "None".to_string(),
    }
}
fn to_rust_energy_vec(energy_types: &Vec<EnergyType>) -> String {
    let mut result = "vec![".to_string();
    for energy_type in energy_types {
        result.push_str(&format!("EnergyType::{energy_type},"));
    }
    result.push(']');
    result
}

fn read_existing_attack_ids() -> HashSet<String> {
    let mut existing_ids = HashSet::new();

    if let Ok(file) = File::open("./src/attack_ids.rs") {
        let reader = BufReader::new(file);
        let mut in_enum = false;

        for line in reader.lines() {
            if let Ok(line) = line {
                let trimmed = line.trim();

                // Detect start of enum
                if trimmed.starts_with("pub enum AttackId") {
                    in_enum = true;
                    continue;
                }

                // Detect end of enum
                if in_enum && trimmed == "}" {
                    break;
                }

                // Extract enum variant names
                if in_enum && !trimmed.is_empty() && !trimmed.starts_with("//") {
                    if let Some(variant) = trimmed.strip_suffix(',') {
                        existing_ids.insert(variant.to_string());
                    }
                }
            }
        }
    }

    existing_ids
}

fn print_implementation_ids(
    card_map: &IndexMap<String, Card>,
    _id_to_enum: &IndexMap<String, String>,
) {
    // Read attack_ids.rs to get the list of existing AttackIds
    let existing_attack_ids = read_existing_attack_ids();

    // Collect all attacks with their effect texts
    let mut effect_to_attacks: IndexMap<String, Vec<(String, usize, String)>> = IndexMap::new();
    let mut attack_to_effect: Vec<(String, usize, Option<String>)> = Vec::new();

    for (enum_name, card) in card_map.iter() {
        if let Card::Pokemon(pokemon_card) = card {
            for (attack_idx, attack) in pokemon_card.attacks.iter().enumerate() {
                let effect_text = attack.effect.clone().unwrap_or_else(|| "None".to_string());

                // Store for effect grouping
                effect_to_attacks
                    .entry(effect_text.clone())
                    .or_insert_with(Vec::new)
                    .push((
                        enum_name.clone(),
                        attack_idx,
                        attack.title.clone(),
                    ));

                // Store for attack mapping
                attack_to_effect.push((
                    enum_name.clone(),
                    attack_idx,
                    attack.effect.clone(),
                ));
            }
        }
    }

    // Generate unique effect IDs by normalizing effect text
    let mut unique_effects: IndexMap<String, String> = IndexMap::new();
    let mut effect_counter = 0;

    for (effect_text, _) in effect_to_attacks.iter() {
        if effect_text == "None" {
            unique_effects.insert(effect_text.clone(), "NoEffect".to_string());
        } else {
            let effect_id = format!("Effect{}", effect_counter);
            unique_effects.insert(effect_text.clone(), effect_id);
            effect_counter += 1;
        }
    }

    // Print the generated file
    println!("// This is code generated from the database.json by card_enum_generator.rs. Do not edit manually.");
    println!();
    println!("use crate::attack_ids::AttackId;");
    println!("use std::collections::HashMap;");
    println!("use std::sync::LazyLock;");
    println!();

    // Print effect text enum
    println!("#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]");
    println!("pub enum EffectId {{");
    for (_, effect_id) in unique_effects.iter() {
        println!("    {effect_id},");
    }
    println!("}}");
    println!();

    // Print implementation status enum
    println!("#[derive(Debug, Clone, Copy, PartialEq, Eq)]");
    println!("pub enum ImplementationStatus {{");
    println!("    Implemented,");
    println!("    NotImplemented,");
    println!("}}");
    println!();

    // Print map from AttackId to EffectId
    println!("static ATTACK_EFFECT_MAP: LazyLock<HashMap<AttackId, EffectId>> = LazyLock::new(|| {{");
    println!("    let mut map = HashMap::new();");

    for (enum_name, _attack_idx, effect_opt) in attack_to_effect.iter() {
        // Only generate mappings for attacks that have effects AND exist in attack_ids.rs
        if let Some(effect_text) = effect_opt {
            if existing_attack_ids.contains(enum_name) {
                if let Some(effect_id) = unique_effects.get(effect_text.as_str()) {
                    println!("    map.insert(AttackId::{enum_name}, EffectId::{effect_id});");
                }
            }
        }
    }

    println!("    map");
    println!("}});");
    println!();

    // Print map from EffectId to effect text (for documentation)
    println!("static EFFECT_DESCRIPTIONS: LazyLock<HashMap<EffectId, &'static str>> = LazyLock::new(|| {{");
    println!("    let mut map = HashMap::new();");
    for (effect_text, effect_id) in unique_effects.iter() {
        let escaped_text = effect_text.replace("\\", "\\\\").replace("\"", "\\\"");
        println!("    map.insert(EffectId::{effect_id}, \"{escaped_text}\");");
    }
    println!("    map");
    println!("}});");
    println!();

    // Print helper functions
    println!("impl EffectId {{");
    println!("    /// Get the effect ID for a given attack");
    println!("    pub fn from_attack(attack_id: AttackId) -> Option<Self> {{");
    println!("        ATTACK_EFFECT_MAP.get(&attack_id).copied()");
    println!("    }}");
    println!();
    println!("    /// Get the description text for this effect");
    println!("    pub fn description(&self) -> &'static str {{");
    println!("        EFFECT_DESCRIPTIONS.get(self).copied().unwrap_or(\"Unknown effect\")");
    println!("    }}");
    println!();
    println!("    /// Check if this effect has an implementation");
    println!("    pub fn implementation_status(&self) -> ImplementationStatus {{");
    println!("        // TODO: This should be generated based on actual implementations in apply_attack_action.rs");
    println!("        // For now, returning NotImplemented for all");
    println!("        ImplementationStatus::NotImplemented");
    println!("    }}");
    println!("}}");
    println!();

    // Print statistics as comments
    println!("// Statistics:");
    println!("// Total unique effects: {}", unique_effects.len());
    println!("// Total attacks: {}", attack_to_effect.len());
    println!();
    println!("// Effect groupings (attacks with same effect text):");
    for (effect_text, attacks) in effect_to_attacks.iter() {
        if attacks.len() > 1 {
            let effect_id = unique_effects.get(effect_text).unwrap();
            println!("// {} - {} attacks:", effect_id, attacks.len());
            for (enum_name, _attack_idx, title) in attacks.iter() {
                println!("//   - AttackId::{} ({})", enum_name, title);
            }
            println!("//");
        }
    }
}
